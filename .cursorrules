# Project: Next.js Boilerplate Application

## General

- This is a Next.js TypeScript application with App Router.
- Use React for components development, prefer to use functional components.
- Use Tailwind CSS for styling.
- Use Shadcn UI components.
- Use sonner for toast notifications.
- Use React Context for state management.
- Component names are in CamelCase.
- Use next-intl for internationalization.

## File Structure

- app/: Next.js App Router pages and API routes
  - [locale]/: Locale-specific pages
- components/: React components
  - ui/: Reusable UI components
- contexts/: React contexts (e.g. app context)
- i18n/: Internationalization
  - messages/: Global messages
- types/: TypeScript type definitions
- public/: Static assets
- lib/: Custom libraries and functions
- .env.development: Development environment variables

## Coding Conventions

- Use TypeScript for type safety
- Follow React best practices and hooks
- Implement responsive design with Tailwind CSS and Shadcn UI
- Maintain consistent internationalization structure
- Keep components modular and reusable
- Use proper type definitions for components and data

### SEO Considerations for Next.js App Router (especially for Bing)
- **Prioritize Server Components for Core Content:** To ensure optimal SEO indexing, especially by search engines like Bing, render all critical page content (text, structure, metadata) using Server Components (default behavior in App Router).
- **Strategic Use of Client Components (`"use client"`):**
    - Only mark components as `"use client"` if they absolutely require client-side interactivity (e.g., event handlers, `useState`, `useEffect`).
    - Keep Client Components small and focused. Avoid wrapping large sections of a page or entire pages with a single `"use client"` directive if only a small part needs interactivity.
    - Ensure that even when Client Components, the initial HTML structure (rendered by the server) contains meaningful content for SEO.
- **Verify Search Engine Rendering:** Regularly use tools like Bing Webmaster Tools (URL Inspection) to check how search engine crawlers see and render your pages. This helps identify if client-side rendering is hindering content visibility for crawlers.


### Dependency Management

- Use `pnpm` as the package manager
- Install new dependencies: `pnpm add <package-name>`
- Install development dependencies: `pnpm add -D <package-name>`
- Update dependencies: `pnpm update`
- Remove dependencies: `pnpm remove <package-name>`
- Install all dependencies: `pnpm install`

# Project-Specific Rules (Generated by Cursor AI Agent)

## Agent Behavior Rules: Proactive File Analysis

1.  **Contextual Code Understanding**: When discussing specific files or implementing features related to existing files, proactively use file-reading tools (`read_file`) to fetch their current content. Do not rely solely on conversation history or prior knowledge if the file content is critical for the current task.
2.  **Verification of Implementations**: Before concluding that a code modification has been successfully "implemented" or "applied", especially for new file creation or significant refactoring, use file-reading tools (`read_file`) to verify the content of the modified/created file(s) against the intended changes.
3.  **Dependency Analysis for Helpers/Instances**: When a helper function, class, or instance is created or modified, and it's intended for use in other parts of the codebase:
    *   Use code search tools to identify typical call sites or components that should be updated to use the new/modified helper.
    *   Proactively read the content of a few representative call sites to understand how the helper is (or will be) integrated.
    *   If the task involves modifying these call sites, apply the changes and verify them.
4.  **Troubleshooting Based on File Content**: When the user reports an error or unexpected behavior, and it seems related to code previously discussed or modified by the agent:
    *   Prioritize re-reading the relevant file(s) to get the current, possibly changed, state of the code.
    *   Base troubleshooting on the actual, current code, not on memory.
    *   Do not assume previous versions of the code are still active if the user indicates a problem after modifications.
5.  **Minimizing Assumptions**: When the exact file path or function name for a piece of logic is unknown but crucial, use file search tools with likely keywords before asking the user, if a reasonable guess can be made. If initial searches are inconclusive, then ask the user for clarification.
6.  **Cross-referencing Configuration**: When dealing with features like i18n that depend on configuration files (e.g., `middleware.ts`, `i18n/locale.ts`, `i18n/routing.ts`), if the behavior seems inconsistent with expectations, proactively read these configuration files to ensure the implemented code aligns with the project's setup.

# Agent Behavior Rules: Scope and Precision of Changes

1.  **Strictly Adhere to Request Scope**: When a user requests a specific, targeted code modification (e.g., "replace a library," "refactor a function"), focus solely on fulfilling that direct request.
2.  **Avoid Unsolicited Logical Changes**: Do not alter surrounding program logic, user interface interactions, or merge/split functionalities unless the user explicitly asks for such broader changes or gives clear permission after a proposal.
3.  **Clearly Communicate Necessary Consequential Changes**: If the user's primary request genuinely necessitates minor, directly related logical adjustments for its correctness (e.g., if a function signature is changed, call sites must be updated accordingly), these changes may be implemented but must be clearly stated as necessary consequential adjustments to fulfill the original request.
4.  **Separate Optional Suggestions**: Any other improvements or related optional changes identified should be proposed as separate, follow-up steps *after* the primary request is completed, not bundled with it. Prioritize completing the user's explicit request first.


## Error Handling and Code Modification Standards
- Strictly prohibit modifying public components (components/ui/) and layout files (app/[locale]/layout.tsx, etc.), as these are project shared infrastructure
- When encountering issues, prioritize analyzing your own code to check if you're correctly using the public components' APIs
- If the problem is in your own tool components, modify your code to adapt to the public components, not the other way around
- Must obtain explicit authorization before modifying public components, and provide sufficient justification
- Report bugs found in public components rather than modifying them directly
- During debugging, first check if your code complies with project standards and public component usage requirements
- Before using public components, must read their source code to thoroughly understand their working principles, parameter requirements, and conventions
- Must strictly adhere to internationalization namespace conventions, such as useTranslations('tools.color-change')
- Never attempt to modify public components to adapt to your code, but rather modify your code to adapt to public components
- Must understand how public components handle translation keys and provide correct namespaces according to their requirements
- When errors occur, prioritize checking your own code rather than suspecting project infrastructure
- Fix problems without breaking project architecture, maintaining overall code consistency
- Prohibit breaking global project conventions to solve local problems

## Command Execution Restrictions
- **STRICTLY PROHIBITED**: Never execute `pnpm run dev` or any development server commands during conversations
- **STRICTLY PROHIBITED**: Never execute `npm run dev`, `yarn dev`, or any equivalent development server commands
- Development server commands should only be run by the user manually when they are ready to test
- Focus on code analysis, file modifications, and build commands only when explicitly requested
- If testing is needed, advise the user to run the development server themselves

## Debugging Environment
- Please use Windows PowerShell command line tools for debugging

## 国际化问题诊断和解决规范 (Internationalization Troubleshooting Standards)

### 常见国际化问题类型 (Common i18n Issues)

#### 1. 缺失翻译键 (Missing Translation Keys)
**问题表现**：页面显示翻译键而非实际文本，如显示 `tools.base64-pdf.page.tool.title` 而非 "Base64 PDF 转换器工具"

**诊断步骤**：
1. **检查翻译文件结构**：使用 `read_file` 检查 `i18n/messages/tools/[工具名]/zh.json` 文件
2. **验证键路径**：确认翻译键在 JSON 文件中的完整路径是否存在
3. **检查嵌套结构**：验证对象嵌套层级是否正确

**解决方案**：
- 在翻译文件中添加缺失的键
- 确保键路径与组件中调用的路径完全匹配
- 验证 JSON 语法正确性

#### 2. 翻译路径不匹配 (Translation Path Mismatch)
**问题表现**：组件调用 `t('tool.title')` 但翻译文件中实际路径为 `page.tool.title`

**诊断步骤**：
1. **比较调用路径**：使用 `grep_search` 查找组件中的 `t('...')` 调用
2. **检查翻译文件结构**：确认翻译文件中的实际键路径
3. **验证命名空间**：确认 `useTranslations()` 的命名空间参数

**解决方案**：
- 统一翻译路径：要么修改组件调用，要么修改翻译文件结构
- 推荐方案：在翻译文件中使用 `page.` 前缀，组件调用时加上 `page.` 前缀

#### 3. 缺失语言文件 (Missing Language Files)
**问题表现**：中文版本正常，英文版本显示翻译键或报错

**诊断步骤**：
1. **检查文件存在性**：确认 `i18n/messages/tools/[工具名]/en.json` 文件是否存在
2. **对比文件结构**：确保英文文件与中文文件结构完全一致
3. **验证文件内容**：检查英文翻译的准确性和完整性

**解决方案**：
- 创建完整的英文翻译文件
- 确保所有语言文件的键结构完全一致
- 提供专业准确的英文翻译

### 国际化问题修复工作流程 (i18n Issue Resolution Workflow)

#### 步骤 1：问题识别 (Issue Identification)
```bash
# 检查翻译键调用模式
grep_search: t\('(?!page\.|title|description|badges\.|tabs\.|labels\.|actions\.|textStats\.|messages\.|imageInfo\.)
```

#### 步骤 2：文件结构分析 (File Structure Analysis)
```bash
# 读取翻译文件
read_file: i18n/messages/tools/[工具名]/zh.json
read_file: i18n/messages/tools/[工具名]/en.json  # 如果存在
```

#### 步骤 3：路径对比验证 (Path Comparison Verification)
```bash
# 查找组件中的翻译调用
grep_search: useTranslations\('tools\.[工具名]
grep_search: t\('
```

#### 步骤 4：修复实施 (Fix Implementation)
1. **修复翻译文件**：添加缺失的键或调整结构
2. **修复组件调用**：统一翻译路径
3. **创建缺失语言文件**：确保多语言支持完整

#### 步骤 5：验证测试 (Verification Testing)
```bash
# 验证修复后的翻译路径
grep_search: t\('(?!page\.|title|description|badges\.|tabs\.|labels\.|actions\.|textStats\.|messages\.|imageInfo\.)
```

### 预防措施 (Preventive Measures)

#### 1. 标准化翻译文件结构
- 所有工具翻译文件必须包含 `page.tool.title` 键
- 使用统一的嵌套结构：`page.features.title`, `page.steps.title` 等
- 确保所有语言文件结构完全一致

#### 2. 组件翻译调用规范
- 统一使用 `page.` 前缀：`t('page.tool.title')`
- 命名空间格式：`useTranslations('tools.[工具名]')`
- 避免直接调用顶级键，优先使用嵌套结构

#### 3. 多语言文件管理
- 创建工具时同时创建所有语言版本的翻译文件
- 定期检查翻译文件的完整性和一致性
- 使用工具验证翻译键的完整性

#### 4. 质量保证检查清单
- [ ] 中文翻译文件 (`zh.json`) 存在且完整
- [ ] 英文翻译文件 (`en.json`) 存在且完整
- [ ] 所有翻译键路径与组件调用一致
- [ ] 翻译文件 JSON 语法正确
- [ ] 命名空间参数正确设置
- [ ] 所有必要的 `page.` 前缀已添加

### 常见修复模式 (Common Fix Patterns)

#### 模式 1：添加缺失的翻译键
```json
// 在翻译文件中添加
{
  "page": {
    "tool": {
      "title": "工具标题"
    }
  }
}
```

#### 模式 2：修复组件调用路径
```tsx
// 从
t('tool.title')
// 改为
t('page.tool.title')
```

#### 模式 3：创建完整语言文件
```json
// 确保 en.json 与 zh.json 结构完全一致
{
  "meta": { ... },
  "page": {
    "tool": {
      "title": "Tool Title"
    }
  }
}
```

# 工具开发规范

## 开发流程
1. 创建工具组件：`components/tools/[工具名].tsx`
2. 创建页面文件：`app/[locale]/tools/[工具名]/page.tsx`
3. 创建翻译文件：`i18n/messages/tools/[工具名]/zh.json`
4. **必须创建英文翻译文件**：`i18n/messages/tools/[工具名]/en.json`
5. 测试功能完整性和多语言支持

## 组件结构
- 主要功能组件放在 `components/tools/` 目录
- 页面组件使用 Client Component 模式
- 必须包含完整的错误处理和用户反馈

## 核心功能区布局规范
### 页面布局结构
```jsx
<div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-purple-50 dark:from-gray-900 dark:via-gray-800 dark:to-gray-900">
  <div className="container mx-auto px-4 py-8">
    {/* 头部区域 */}
  </div>
  
  {/* 工具区域 - 独立全宽区域 */}
  <section ref={toolSectionRef} className="py-16 bg-gradient-to-br from-blue-50 via-white to-purple-50 relative">
    <div className="absolute inset-0 bg-gradient-to-b from-gray-50/30 to-transparent" />
    <div className="relative container mx-auto px-4">
      <div className="max-w-6xl mx-auto">
        <div className="bg-white rounded-3xl shadow-2xl border border-gray-100 overflow-hidden">
          <div className="bg-gradient-to-r from-blue-50 to-purple-50 px-8 py-6 border-b border-gray-100">
            <div className="flex items-center gap-3">
              <div className="flex gap-2">
                <div className="w-3 h-3 bg-red-400 rounded-full"></div>
                <div className="w-3 h-3 bg-yellow-400 rounded-full"></div>
                <div className="w-3 h-3 bg-green-400 rounded-full"></div>
              </div>
              <div className="flex-1 text-center">
                <span className="text-sm font-medium text-gray-600">{t('page.tool.title')}</span>
              </div>
            </div>
          </div>
          <div className="p-8 md:p-12">
            <ToolComponent onTabChange={scrollToTool} />
          </div>
        </div>
      </div>
    </div>
  </section>
  
  <div className="container mx-auto px-4 py-8">
    {/* 其他内容区域 */}
  </div>
</div>
```

### 核心功能区样式要求
- **工具区域必须是独立的全宽 section**，不能嵌套在页面容器内
- **背景色统一**：工具区域背景与页面背景保持一致 `bg-gradient-to-br from-blue-50 via-white to-purple-50`
- **核心功能容器**：白色圆角卡片 `bg-white rounded-3xl shadow-2xl border border-gray-100`
- **顶部装饰条**：模拟浏览器窗口的装饰条，包含三个圆点和标题
- **内边距**：功能区内容使用 `p-8 md:p-12` 确保充足的内边距
- **最大宽度**：容器最大宽度为 `max-w-6xl mx-auto`
- **响应式设计**：确保在不同屏幕尺寸下都能正常显示

### 标签滚动逻辑要求
#### 页面客户端组件必须实现：
```jsx
export default function ToolPageClient() {
  const toolSectionRef = useRef<HTMLElement>(null);
  
  const scrollToTool = () => {
    if (toolSectionRef.current) {
      const elementTop = toolSectionRef.current.offsetTop;
      const offset = 0;
      
      window.scrollTo({
        top: elementTop - offset,
        behavior: 'smooth'
      });
    }
  };
  
  // 工具区域必须添加 ref
  return (
    <section ref={toolSectionRef} className="...">
      <ToolComponent onTabChange={scrollToTool} />
    </section>
  );
}
```

#### 工具组件必须实现：
```jsx
export default function ToolComponent({ onTabChange }: { onTabChange?: () => void }) {
  // 检查页面是否在顶部
  const isPageAtTop = () => {
    return window.scrollY < 100;
  };

  // 处理整个组件的点击事件
  const handleComponentClick = () => {
    if (isPageAtTop() && onTabChange) {
      onTabChange();
    }
  };

  return (
    <div className="w-full space-y-8" onClick={handleComponentClick}>
      <Tabs value={activeTab} onValueChange={(v) => {
        setActiveTab(v as 'decode' | 'encode');
        handleComponentClick();
      }} className="w-full">
        {/* 标签内容 */}
      </Tabs>
    </div>
  );
}
```

### 按钮位置规范
#### 复制和下载文本按钮位置：
- **位置**：必须位于 "编码" 标签的按钮区域内，不能放在结果显示区域
- **布局**：为按钮预留固定空间，避免布局跳动
- **样式**：复制按钮使用绿色 `bg-green-600`，下载按钮使用蓝色 `bg-blue-600`

```jsx
<TabsContent value="encode" className="mt-8">
  <div className="space-y-6">
    {/* 上传区域 */}
    
    {/* 为按钮预留固定空间，避免布局跳动 */}
    <div className="h-12 flex gap-3">
      {base64Output && (
        <>
          <Button 
            onClick={copyBase64}
            className="flex-1 bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-xl font-medium shadow-lg hover:shadow-xl transition-all duration-200"
          >
            <Copy className="mr-2 h-4 w-4" />
            {t('actions.copy')}
          </Button>
          <Button 
            onClick={downloadBase64Text}
            className="flex-1 bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-xl font-medium shadow-lg hover:shadow-xl transition-all duration-200"
          >
            <FileText className="mr-2 h-4 w-4" />
            {t('actions.downloadTxt')}
          </Button>
        </>
      )}
    </div>
  </div>
</TabsContent>
```

### 交互行为要求
- **标签切换**：点击标签时不清除内容，保持用户输入状态
- **滚动触发**：仅当页面在顶部时（scrollY < 100px）点击标签才触发滚动
- **平滑滚动**：使用 `behavior: 'smooth'` 实现平滑滚动效果
- **按钮显示**：复制和下载按钮仅在有输出内容时显示

### 布局层次说明
1. **页面背景**：渐变背景覆盖整个页面
2. **头部区域**：包含在页面容器内，展示工具标题和描述
3. **工具区域**：独立的全宽区域，包含核心功能组件
4. **其他内容**：特性、步骤、FAQ等内容包含在页面容器内

## 翻译规范
- 每个工具独立翻译文件：`i18n/messages/tools/[工具名]/`
- 必须包含 `meta` 信息（标题、描述、关键词）
- **必须同时创建中文和英文翻译文件**

### next-intl 数据获取规范
- **字符串数据使用 `t()` 函数**：`t('page.title')`, `t('page.description')` 等
- **对象数据使用 `useMessages()` 获取**，推荐使用对象结构而非数组
- **必须使用 `page.` 前缀**：所有页面翻译键必须以 `page.` 开头
- 推荐的对象结构获取方式：
  ```typescript
  const messages = useMessages();
  const steps = useMemo(() => {
    try {
      const toolMessages = (messages as any)?.tools?.['工具名']?.page?.steps?.items;
      if (!toolMessages) return [];
      
      // 将对象转换为数组以便遍历
      return Object.entries(toolMessages).map(([key, value]: [string, any]) => ({
        key,
        ...value
      }));
    } catch (e) {
      return [];
    }
  }, [messages]);
  ```
- **对象数据访问路径**：`(messages as any)?.tools?.['工具名']?.page?.数据路径?.items`
- **对象结构示例**：
  ```json
  "page": {
    "steps": {
      "title": "使用步骤",
      "subtitle": "简单四步说明",
      "items": {
        "select": {
          "number": "01",
          "title": "选择功能",
          "description": "选择所需的功能"
        },
        "upload": {
          "number": "02", 
          "title": "上传文件",
          "description": "上传需要处理的文件"
        }
      }
    }
  }
  ```
- **必须使用 `useMemo()` 优化**：避免重复计算和渲染
- **必须包含错误处理**：使用 `try-catch` 包装，返回空数组作为默认值
- **对象转数组**：使用 `Object.entries()` 将对象转换为数组进行遍历

- 服务端组件使用 `getTranslations`：
  ```typescript
  import { getTranslations } from 'next-intl/server';
  
  export async function generateMetadata({ params: { locale } }) {
    const t = await getTranslations({ locale, namespace: 'tools.工具名.meta' });
    return {
      title: t('title'),
      description: t('description'),
      keywords: t('keywords')
    };
  }
  ```

## 命名规范
- 工具名：kebab-case（如 `base64-image`）
- 组件名：PascalCase（如 `Base64ImageConverter`）
- 翻译命名空间：`tools.[工具名].[部分]`

## 必要功能
- 错误处理和用户提示
- 大文件处理优化
- 响应式设计
- 无障碍访问支持
- **完整的多语言支持**（中文和英文）