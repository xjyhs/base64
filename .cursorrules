# Project: Next.js Boilerplate Application

## General

- This is a Next.js TypeScript application with App Router.
- Use React for components development, prefer to use functional components.
- Use Tailwind CSS for styling.
- Use Shadcn UI components.
- Use sonner for toast notifications.
- Use React Context for state management.
- Component names are in CamelCase.
- Use next-intl for internationalization.

## File Structure

- app/: Next.js App Router pages and API routes
  - [locale]/: Locale-specific pages
- components/: React components
  - ui/: Reusable UI components
- contexts/: React contexts (e.g. app context)
- i18n/: Internationalization
  - messages/: Global messages
- types/: TypeScript type definitions
- public/: Static assets
- lib/: Custom libraries and functions
- .env.development: Development environment variables

## Coding Conventions

- Use TypeScript for type safety
- Follow React best practices and hooks
- Implement responsive design with Tailwind CSS and Shadcn UI
- Maintain consistent internationalization structure
- Keep components modular and reusable
- Use proper type definitions for components and data

### SEO Considerations for Next.js App Router (especially for Bing)
- **Prioritize Server Components for Core Content:** To ensure optimal SEO indexing, especially by search engines like Bing, render all critical page content (text, structure, metadata) using Server Components (default behavior in App Router).
- **Strategic Use of Client Components (`"use client"`):**
    - Only mark components as `"use client"` if they absolutely require client-side interactivity (e.g., event handlers, `useState`, `useEffect`).
    - Keep Client Components small and focused. Avoid wrapping large sections of a page or entire pages with a single `"use client"` directive if only a small part needs interactivity.
    - Ensure that even when using Client Components, the initial HTML structure (rendered by the server) contains meaningful content for SEO.
- **Verify Search Engine Rendering:** Regularly use tools like Bing Webmaster Tools (URL Inspection) to check how search engine crawlers see and render your pages. This helps identify if client-side rendering is hindering content visibility for crawlers.


### Dependency Management

- Use `pnpm` as the package manager
- Install new dependencies: `pnpm add <package-name>`
- Install development dependencies: `pnpm add -D <package-name>`
- Update dependencies: `pnpm update`
- Remove dependencies: `pnpm remove <package-name>`
- Install all dependencies: `pnpm install`

# Project-Specific Rules (Generated by Cursor AI Agent)

## Agent Behavior Rules: Proactive File Analysis

1.  **Contextual Code Understanding**: When discussing specific files or implementing features related to existing files, proactively use file-reading tools (`read_file`) to fetch their current content. Do not rely solely on conversation history or prior knowledge if the file content is critical for the current task.
2.  **Verification of Implementations**: Before concluding that a code modification has been successfully "implemented" or "applied", especially for new file creation or significant refactoring, use file-reading tools (`read_file`) to verify the content of the modified/created file(s) against the intended changes.
3.  **Dependency Analysis for Helpers/Instances**: When a helper function, class, or instance is created or modified, and it's intended for use in other parts of the codebase:
    *   Use code search tools to identify typical call sites or components that should be updated to use the new/modified helper.
    *   Proactively read the content of a few representative call sites to understand how the helper is (or will be) integrated.
    *   If the task involves modifying these call sites, apply the changes and verify them.
4.  **Troubleshooting Based on File Content**: When the user reports an error or unexpected behavior, and it seems related to code previously discussed or modified by the agent:
    *   Prioritize re-reading the relevant file(s) to get the current, possibly changed, state of the code.
    *   Base troubleshooting on the actual, current code, not on memory.
    *   Do not assume previous versions of the code are still active if the user indicates a problem after modifications.
5.  **Minimizing Assumptions**: When the exact file path or function name for a piece of logic is unknown but crucial, use file search tools with likely keywords before asking the user, if a reasonable guess can be made. If initial searches are inconclusive, then ask the user for clarification.
6.  **Cross-referencing Configuration**: When dealing with features like i18n that depend on configuration files (e.g., `middleware.ts`, `i18n/locale.ts`, `i18n/routing.ts`), if the behavior seems inconsistent with expectations, proactively read these configuration files to ensure the implemented code aligns with the project's setup.

# Agent Behavior Rules: Scope and Precision of Changes

1.  **Strictly Adhere to Request Scope**: When a user requests a specific, targeted code modification (e.g., "replace a library," "refactor a function"), focus solely on fulfilling that direct request.
2.  **Avoid Unsolicited Logical Changes**: Do not alter surrounding program logic, user interface interactions, or merge/split functionalities unless the user explicitly asks for such broader changes or gives clear permission after a proposal.
3.  **Clearly Communicate Necessary Consequential Changes**: If the user's primary request genuinely necessitates minor, directly related logical adjustments for its correctness (e.g., if a function signature is changed, call sites must be updated accordingly), these changes may be implemented but must be clearly stated as necessary consequential adjustments to fulfill the original request.
4.  **Separate Optional Suggestions**: Any other improvements or related optional changes identified should be proposed as separate, follow-up steps *after* the primary request is completed, not bundled with it. Prioritize completing the user's explicit request first.


## Error Handling and Code Modification Standards
- Strictly prohibit modifying public components (components/ui/) and layout files (app/[locale]/layout.tsx, etc.), as these are project shared infrastructure
- When encountering issues, prioritize analyzing your own code to check if you're correctly using the public components' APIs
- If the problem is in your own tool components, modify your code to adapt to the public components, not the other way around
- Must obtain explicit authorization before modifying public components, and provide sufficient justification
- Report bugs found in public components rather than modifying them directly
- During debugging, first check if your code complies with project standards and public component usage requirements
- Before using public components, must read their source code to thoroughly understand their working principles, parameter requirements, and conventions
- Must strictly adhere to internationalization namespace conventions, such as useTranslations('tools.color-change')
- Never attempt to modify public components to adapt to your code, but rather modify your code to adapt to public components
- Must understand how public components handle translation keys and provide correct namespaces according to their requirements
- When errors occur, prioritize checking your own code rather than suspecting project infrastructure
- Fix problems without breaking project architecture, maintaining overall code consistency
- Prohibit breaking global project conventions to solve local problems

## Command Execution Restrictions
- **STRICTLY PROHIBITED**: Never execute `pnpm run dev` or any development server commands during conversations
- **STRICTLY PROHIBITED**: Never execute `npm run dev`, `yarn dev`, or any equivalent development server commands
- Development server commands should only be run by the user manually when they are ready to test
- Focus on code analysis, file modifications, and build commands only when explicitly requested
- If testing is needed, advise the user to run the development server themselves

## Debugging Environment
- Please use Windows PowerShell command line tools for debugging

# 工具开发规范

## 开发流程
1. 创建工具组件：`components/tools/[工具名].tsx`
2. 创建页面文件：`app/[locale]/tools/[工具名]/page.tsx`
3. 创建翻译文件：`i18n/messages/tools/[工具名]/zh.json`
4. 测试功能完整性

## 组件结构
- 主要功能组件放在 `components/tools/` 目录
- 页面组件使用 Client Component 模式
- 必须包含完整的错误处理和用户反馈

## 翻译规范
- 每个工具独立翻译文件：`i18n/messages/tools/[工具名]/`
- 必须包含 `meta` 信息（标题、描述、关键词）

### next-intl 数据获取规范
- **字符串数据使用 `t()` 函数**：`t('title')`, `t('description')` 等
- **对象数据使用 `useMessages()` 获取**，推荐使用对象结构而非数组
- 推荐的对象结构获取方式：
  ```typescript
  const messages = useMessages();
  const steps = useMemo(() => {
    try {
      const toolMessages = (messages as any)?.tools?.['工具名']?.page?.steps?.items;
      if (!toolMessages) return [];
      
      // 将对象转换为数组以便遍历
      return Object.entries(toolMessages).map(([key, value]: [string, any]) => ({
        key,
        ...value
      }));
    } catch (e) {
      return [];
    }
  }, [messages]);
  ```
- **对象数据访问路径**：`(messages as any)?.tools?.['工具名']?.page?.数据路径?.items`
- **对象结构示例**：
  ```json
  "steps": {
    "title": "使用步骤",
    "subtitle": "简单四步说明",
    "items": {
      "select": {
        "number": "01",
        "title": "选择功能",
        "description": "选择所需的功能"
      },
      "upload": {
        "number": "02", 
        "title": "上传文件",
        "description": "上传需要处理的文件"
      }
    }
  }
  ```
- **必须使用 `useMemo()` 优化**：避免重复计算和渲染
- **必须包含错误处理**：使用 `try-catch` 包装，返回空数组作为默认值
- **对象转数组**：使用 `Object.entries()` 将对象转换为数组进行遍历

- 服务端组件使用 `getTranslations`：
  ```typescript
  import { getTranslations } from 'next-intl/server';
  
  export async function generateMetadata({ params: { locale } }) {
    const t = await getTranslations({ locale, namespace: 'tools.工具名.meta' });
    return {
      title: t('title'),
      description: t('description'),
      keywords: t('keywords')
    };
  }
  ```

## 命名规范
- 工具名：kebab-case（如 `base64-image`）
- 组件名：PascalCase（如 `Base64ImageConverter`）
- 翻译命名空间：`tools.[工具名].[部分]`

## 必要功能
- 错误处理和用户提示
- 大文件处理优化
- 响应式设计
- 无障碍访问支持