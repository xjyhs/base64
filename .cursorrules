# Project: Next.js Boilerplate Application

## General

- This is a Next.js TypeScript application with App Router.
- Use React for components development, prefer to use functional components.
- Use Tailwind CSS for styling.
- Use Shadcn UI components.
- Use sonner for toast notifications.
- Use React Context for state management.
- Component names are in CamelCase.
- Use next-auth for authentication.
- Use next-intl for internationalization.
- Use Stripe for payment.

## File Structure

- app/: Next.js App Router pages and API routes
  - [locale]/: Locale-specific pages
  - api/: API routes (e.g. checkout)
  - theme.css: Theme styles
- components/: React components
  - blocks/: Layout blocks (header, footer, etc.), commonly used in Landing Page
  - ui/: Reusable UI components
- contexts/: React contexts (e.g. app context)
- i18n/: Internationalization
  - pages/landing/: Page-specific translations for Landing Page
  - messages/: Global messages
- types/: TypeScript type definitions
  - blocks/: Types for layout blocks
  - pages/: Types for pages
- models/: Data models and data operations.
- services/: Business logics.
- public/: Static assets
- lib/: Custom libraries and functions
- .env.development: Development environment variables

## Coding Conventions

- Use TypeScript for type safety
- Follow React best practices and hooks
- Implement responsive design with Tailwind CSS and Shadcn UI
- Maintain consistent internationalization structure
- Keep components modular and reusable
- Use proper type definitions for components and data

### SEO Considerations for Next.js App Router (especially for Bing)
- **Prioritize Server Components for Core Content:** To ensure optimal SEO indexing, especially by search engines like Bing, render all critical page content (text, structure, metadata) using Server Components (default behavior in App Router).
- **Strategic Use of Client Components (`"use client"`):**
    - Only mark components as `"use client"` if they absolutely require client-side interactivity (e.g., event handlers, `useState`, `useEffect`).
    - Keep Client Components small and focused. Avoid wrapping large sections of a page or entire pages with a single `"use client"` directive if only a small part needs interactivity.
    - Ensure that even when using Client Components, the initial HTML structure (rendered by the server) contains meaningful content for SEO.
- **Verify Search Engine Rendering:** Regularly use tools like Bing Webmaster Tools (URL Inspection) to check how search engine crawlers see and render your pages. This helps identify if client-side rendering is hindering content visibility for crawlers.


### Dependency Management

- Use `pnpm` as the package manager
- Install new dependencies: `pnpm add <package-name>`
- Install development dependencies: `pnpm add -D <package-name>`
- Update dependencies: `pnpm update`
- Remove dependencies: `pnpm remove <package-name>`
- Install all dependencies: `pnpm install`

# Project-Specific Rules (Generated by Cursor AI Agent)

## API Client (`lib/axiosInstance.ts`)

1.  **Purpose**: Provides a centralized Axios instance (`axiosInstance`) for making API calls.
2.  **Internationalization (i18n)**:
    *   It includes a **request interceptor** that automatically attempts to read the `NEXT_LOCALE` cookie.
    *   If the `NEXT_LOCALE` cookie is found, its value is attached as a `locale` query parameter to outgoing API requests.
    *   This allows API routes to determine the language context from the request.
    *   Logs to the console indicating whether the `locale` was attached or if the `NEXT_LOCALE` cookie was not found.
3.  **Usage**: Import `axiosInstance from '@/lib/axiosInstance'` in client-side code (e.g., React components) and use it for API calls instead of the global `axios` object if automatic `locale` attachment is desired.
    ```typescript
    import axiosInstance from '@/lib/axiosInstance';
    // ...
    // const response = await axiosInstance.post('/some/api/endpoint', data);
    ```
4.  **Error Handling**: Standard Axios error handling applies. The interceptor itself does not modify error handling but includes a `Promise.reject(error)` for request errors.
5.  **Dependencies**: Relies on `axios`. Ensure `axios` and its type definitions (`@types/axios`) are installed.

## API Internationalization Helper (`app/api/_lib/i18n.ts`)

1.  **Purpose**: Provides a shared function `getApiTranslator(request: NextRequest)` for use in Next.js API routes to obtain an i18n translator instance configured for the current request's language.
2.  **Locale Detection Strategy**:
    *   **Primary**: Reads the `locale` query parameter from the `request.url`. This parameter is expected to be set by the client-side `axiosInstance` interceptor (which reads it from the `NEXT_LOCALE` cookie).
    *   **Fallback**: If the `locale` query parameter is not found or is invalid, it attempts to parse the `accept-language` header from the request. It maps specific locales (e.g., `zh-CN`) to base locales (e.g., `zh`) if defined in `@/i18n/locale.ts`.
    *   **Default**: If a supported locale cannot be determined from the above methods, it defaults to `defaultLocale` as defined in `@/i18n/locale.ts`.
3.  **Message Loading**:
    *   Dynamically imports the message file (e.g., `en.json`, `zh.json`) from `@/i18n/messages/` based on the determined locale.
4.  **Error Handling**:
    *   If loading the determined locale's messages fails, it attempts to fall back to loading the `defaultLocale`'s messages.
    *   If loading the `defaultLocale`'s messages also fails, it returns a dummy translator with a critical error message to prevent the API route from crashing entirely.
    *   Logs errors to the console at various stages.
5.  **Usage**: In API route handlers (e.g., `app/api/some-route/route.ts`):
    ```typescript
    import { getApiTranslator } from '@/app/api/_lib/i18n';
    // ...
    export async function POST(request: NextRequest) {
      const t = await getApiTranslator(request);
      // ... use t('translation.key') ...
    }
    ```
6.  **Dependencies**:
    *   `next/server` (for `NextRequest`)
    *   `next-intl` (for `createTranslator`)
    *   `@/i18n/locale` (for `locales`, `defaultLocale`)
    *   Message files in `@/i18n/messages/`

## Agent Behavior Rules: Proactive File Analysis

1.  **Contextual Code Understanding**: When discussing specific files or implementing features related to existing files (e.g., `axiosInstance.ts`, `app/api/_lib/i18n.ts`, API routes, client-side components making API calls), proactively use file-reading tools (`read_file`) to fetch their current content. Do not rely solely on conversation history or prior knowledge if the file content is critical for the current task.
2.  **Verification of Implementations**: Before concluding that a code modification has been successfully "implemented" or "applied", especially for new file creation or significant refactoring, use file-reading tools (`read_file`) to verify the content of the modified/created file(s) against the intended changes.
3.  **Dependency Analysis for Helpers/Instances**: When a helper function, class, or instance (like `getApiTranslator` or `axiosInstance`) is created or modified, and it's intended for use in other parts of the codebase:
    *   Use code search tools (`codebase_search`, `grep_search`) to identify typical call sites or components that should be updated to use the new/modified helper.
    *   Proactively read the content of a few representative call sites to understand how the helper is (or will be) integrated.
    *   If the task involves modifying these call sites, apply the changes and verify them.
4.  **Troubleshooting Based on File Content**: When the user reports an error or unexpected behavior, and it seems related to code previously discussed or modified by the agent:
    *   Prioritize re-reading the relevant file(s) to get the current, possibly changed, state of the code.
    *   Base troubleshooting япон
    *   Do not assume previous versions of the code are still active if the user indicates a problem after modifications.
5.  **Minimizing Assumptions**: When the exact file path or function name for a piece of logic is unknown but crucial, use file search tools (`file_search`, `codebase_search`) with likely keywords before asking the user, if a reasonable guess can be made. If initial searches are inconclusive, then ask the user for clarification.
6.  **Cross-referencing Configuration**: When dealing with features like i18n that depend on configuration files (e.g., `middleware.ts`, `i18n/locale.ts`, `i18n/routing.ts`), if the behavior seems inconsistent with expectations, proactively read these configuration files to ensure the implemented code aligns with the project's setup.

# Agent Behavior Rules: Scope and Precision of Changes

1.  **Strictly Adhere to Request Scope**: When a user requests a specific, targeted code modification (e.g., "replace library A with library B," "refactor function X," "replace axios with axiosInstance"), focus solely on fulfilling that direct request.
2.  **Avoid Unsolicited Logical Changes**: Do not alter surrounding program logic, user interface interactions, or merge/split functionalities unless the user explicitly asks for such broader changes or gives clear permission after a proposal.
3.  **Clearly Communicate Necessary Consequential Changes**: If the user's primary request genuinely necessitates minor, directly related logical adjustments for its correctness (e.g., if a function signature is changed, call sites must be updated accordingly), these changes may be implemented but must be clearly stated as necessary consequential adjustments to fulfill the original request.
4.  **Separate Optional Suggestions**: Any other improvements or related optional changes identified should be proposed as separate, follow-up steps *after* the primary request is completed, not bundled with it. Prioritize completing the user's explicit request first.


## Error Handling and Code Modification Standards
- Strictly prohibit modifying public components (components/ui/) and layout files (app/[locale]/layout.tsx, etc.), as these are project shared infrastructure
- When encountering issues, prioritize analyzing your own code to check if you're correctly using the public components' APIs
- If the problem is in your own tool components, modify your code to adapt to the public components, not the other way around
- Must obtain explicit authorization before modifying public components, and provide sufficient justification
- Report bugs found in public components rather than modifying them directly
- During debugging, first check if your code complies with project standards and public component usage requirements
- Before using public components, must read their source code to thoroughly understand their working principles, parameter requirements, and conventions
- Must strictly adhere to internationalization namespace conventions, such as useTranslations('tools.color-change')
- Never attempt to modify public components to adapt to your code, but rather modify your code to adapt to public components
- Must understand how public components handle translation keys and provide correct namespaces according to their requirements
- When errors occur, prioritize checking your own code rather than suspecting project infrastructure
- Fix problems without breaking project architecture, maintaining overall code consistency
- Prohibit breaking global project conventions to solve local problems


## Debugging Environment
- Please use Windows PowerShell command line tools for debugging