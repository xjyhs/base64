# Project: Next.js Boilerplate Application

## General

- This is a Next.js TypeScript application with App Router.
- Use React for components development, prefer to use functional components.
- Use Tailwind CSS for styling.
- Use Shadcn UI components.
- Use sonner for toast notifications.
- Use React Context for state management.
- Component names are in CamelCase.
- Use next-intl for internationalization.

## File Structure

- app/: Next.js App Router pages and API routes
  - [locale]/: Locale-specific pages
- components/: React components
  - ui/: Reusable UI components
- contexts/: React contexts (e.g. app context)
- i18n/: Internationalization
  - messages/: Global messages
- types/: TypeScript type definitions
- public/: Static assets
- lib/: Custom libraries and functions
- .env.development: Development environment variables

## Coding Conventions

- Use TypeScript for type safety
- Follow React best practices and hooks
- Implement responsive design with Tailwind CSS and Shadcn UI
- Maintain consistent internationalization structure
- Keep components modular and reusable
- Use proper type definitions for components and data

### SEO Considerations for Next.js App Router (especially for Bing)
- **Prioritize Server Components for Core Content:** To ensure optimal SEO indexing, especially by search engines like Bing, render all critical page content (text, structure, metadata) using Server Components (default behavior in App Router).
- **Strategic Use of Client Components (`"use client"`):**
    - Only mark components as `"use client"` if they absolutely require client-side interactivity (e.g., event handlers, `useState`, `useEffect`).
    - Keep Client Components small and focused. Avoid wrapping large sections of a page or entire pages with a single `"use client"` directive if only a small part needs interactivity.
    - Ensure that even when using Client Components, the initial HTML structure (rendered by the server) contains meaningful content for SEO.
- **Verify Search Engine Rendering:** Regularly use tools like Bing Webmaster Tools (URL Inspection) to check how search engine crawlers see and render your pages. This helps identify if client-side rendering is hindering content visibility for crawlers.


### Dependency Management

- Use `pnpm` as the package manager
- Install new dependencies: `pnpm add <package-name>`
- Install development dependencies: `pnpm add -D <package-name>`
- Update dependencies: `pnpm update`
- Remove dependencies: `pnpm remove <package-name>`
- Install all dependencies: `pnpm install`

# Project-Specific Rules (Generated by Cursor AI Agent)

## Agent Behavior Rules: Proactive File Analysis

1.  **Contextual Code Understanding**: When discussing specific files or implementing features related to existing files, proactively use file-reading tools (`read_file`) to fetch their current content. Do not rely solely on conversation history or prior knowledge if the file content is critical for the current task.
2.  **Verification of Implementations**: Before concluding that a code modification has been successfully "implemented" or "applied", especially for new file creation or significant refactoring, use file-reading tools (`read_file`) to verify the content of the modified/created file(s) against the intended changes.
3.  **Dependency Analysis for Helpers/Instances**: When a helper function, class, or instance is created or modified, and it's intended for use in other parts of the codebase:
    *   Use code search tools to identify typical call sites or components that should be updated to use the new/modified helper.
    *   Proactively read the content of a few representative call sites to understand how the helper is (or will be) integrated.
    *   If the task involves modifying these call sites, apply the changes and verify them.
4.  **Troubleshooting Based on File Content**: When the user reports an error or unexpected behavior, and it seems related to code previously discussed or modified by the agent:
    *   Prioritize re-reading the relevant file(s) to get the current, possibly changed, state of the code.
    *   Base troubleshooting on the actual, current code, not on memory.
    *   Do not assume previous versions of the code are still active if the user indicates a problem after modifications.
5.  **Minimizing Assumptions**: When the exact file path or function name for a piece of logic is unknown but crucial, use file search tools with likely keywords before asking the user, if a reasonable guess can be made. If initial searches are inconclusive, then ask the user for clarification.
6.  **Cross-referencing Configuration**: When dealing with features like i18n that depend on configuration files (e.g., `middleware.ts`, `i18n/locale.ts`, `i18n/routing.ts`), if the behavior seems inconsistent with expectations, proactively read these configuration files to ensure the implemented code aligns with the project's setup.

# Agent Behavior Rules: Scope and Precision of Changes

1.  **Strictly Adhere to Request Scope**: When a user requests a specific, targeted code modification (e.g., "replace a library," "refactor a function"), focus solely on fulfilling that direct request.
2.  **Avoid Unsolicited Logical Changes**: Do not alter surrounding program logic, user interface interactions, or merge/split functionalities unless the user explicitly asks for such broader changes or gives clear permission after a proposal.
3.  **Clearly Communicate Necessary Consequential Changes**: If the user's primary request genuinely necessitates minor, directly related logical adjustments for its correctness (e.g., if a function signature is changed, call sites must be updated accordingly), these changes may be implemented but must be clearly stated as necessary consequential adjustments to fulfill the original request.
4.  **Separate Optional Suggestions**: Any other improvements or related optional changes identified should be proposed as separate, follow-up steps *after* the primary request is completed, not bundled with it. Prioritize completing the user's explicit request first.


## Error Handling and Code Modification Standards
- Strictly prohibit modifying public components (components/ui/) and layout files (app/[locale]/layout.tsx, etc.), as these are project shared infrastructure
- When encountering issues, prioritize analyzing your own code to check if you're correctly using the public components' APIs
- If the problem is in your own tool components, modify your code to adapt to the public components, not the other way around
- Must obtain explicit authorization before modifying public components, and provide sufficient justification
- Report bugs found in public components rather than modifying them directly
- During debugging, first check if your code complies with project standards and public component usage requirements
- Before using public components, must read their source code to thoroughly understand their working principles, parameter requirements, and conventions
- Must strictly adhere to internationalization namespace conventions, such as useTranslations('tools.color-change')
- Never attempt to modify public components to adapt to your code, but rather modify your code to adapt to public components
- Must understand how public components handle translation keys and provide correct namespaces according to their requirements
- When errors occur, prioritize checking your own code rather than suspecting project infrastructure
- Fix problems without breaking project architecture, maintaining overall code consistency
- Prohibit breaking global project conventions to solve local problems


## Debugging Environment
- Please use Windows PowerShell command line tools for debugging